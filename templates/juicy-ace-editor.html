<!--
    Custom Element with Ace code editor
    http://juicy.github.io/juicy-ace-editor/
    version: 1.1.1
    @demo index.html
-->
<script src="../src/external/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script src="../src/external/ace/ext-modelist.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" src="../src/external/ResizeSensor.js"></script>

<!-- modes -->
<!-- <script src="../src/external/ace-modes/mode-text.js" type="text/javascript" charset="utf-8"></script>
<script src="../src/external/ace-modes/mode-javascript.js" type="text/javascript" charset="utf-8"></script>
<script src="../src/external/ace-modes/mode-html.js" type="text/javascript" charset="utf-8"></script>
<script src="../src/external/ace-modes/mode-markdown.js" type="text/javascript" charset="utf-8"></script> -->
<!-- themes -->
<!-- <script src="../src/external/ace-themes/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
<script src="../src/external/ace-themes/theme-solarized_light.js" type="text/javascript" charset="utf-8"></script> -->

<template id="juicy-ace-editor">
    <style>
        :host{
            display: block;
            position: relative;
            min-height: 100px;
        }
        #juicy-ace-editor-container{
            width: 100%;
            height: 100%;
            display: block;

            position: absolute;
        }
    </style>
    <div id="juicy-ace-editor-container"></div>
    <content></content>
</template>

<script>
(function(window, document, undefined) {

    // Creates an object based in the HTML Element prototype
    var TomalecAceEditorPrototype = Object.create(HTMLElement.prototype);

    // Fires when an instance was inserted into the document
    TomalecAceEditorPrototype.attachedCallback = function() {
        var text = this.childNodes[0];
        var container = this.container;
        var element = this;

        if(this.editor){
            editor = this.editor;
            this.value = text.textContent || this.value;
        } else {
            // container.appendChild(text);
            container.innerHTML = this.innerHTML || this.value;
            editor = ace.edit(container);
            this.dispatchEvent(new CustomEvent("editor-ready", {detail: editor}));
            this.editor = editor;

            // inject base editor styles
            this.injectTheme('#ace_editor\\.css');
            this.injectTheme('#ace-tm');


            editor.getSession().on('change', function(event){
                element.dispatchEvent(new CustomEvent("change", {detail: event}));
            });
        }

        // handle theme changes
        editor.renderer.addEventListener("themeLoaded", this.onThemeLoaded.bind(this));

        // initial attributes
            editor.setTheme( this.getAttribute("theme") );
            editor.setFontSize( this.getAttribute("fontsize") );
            editor.setReadOnly( this.getAttribute("readonly") );
            var session = editor.getSession();
            session.setMode( this.getAttribute("mode") );
            session.setUseSoftTabs( this.getAttribute("softtabs") );
            this.getAttribute("tabsize") && session.setTabSize( this.getAttribute("tabsize") );
            session.setUseWrapMode( this.hasAttribute("wrapmode") );


        // Observe input textNode changes
        // Could be buggy as editor was also added to Light DOM;
            var observer = new MutationObserver(function(mutations) {
              mutations.forEach(function(mutation) {
                // console.log("observation", mutation.type, arguments, mutations, editor, text);
                if(mutation.type == "characterData"){
                    element.value = text.data;
                }
              });
            });
            text && observer.observe(text, { characterData: true });
        // container.appendChild(text);
        this._attached = true;

        this.customizeEditor();


        // editor.resize()
        window.setTimeout(function() {
          editor.resize();
        }, 50) // #Hack #Resize #RaceCondition

        var _this = this;
        window.setTimeout(function() {
          // we also use this timeout hack, but we should get rid of it!!
          new ResizeSensor($(_this.container), function() {
            editor.resize();
          });
        }, 500);
    };

    // Fires when an instance was removed from the document
    TomalecAceEditorPrototype.detachedCallback = function() {
        this._attached = false;
    };

    // Fires when an attribute was added, removed, or updated
    TomalecAceEditorPrototype.attributeChangedCallback = function(attr, oldVal, newVal) {
        if(!this._attached){
            return false;
        }
        switch(attr){
            case "theme":
                this.editor.setTheme( newVal );
                break;
            case "mode":
                this.editor.getSession().setMode( newVal );
                break;
            case "fontsize":
                this.editor.setFontSize( newVal );
                break;
            case "softtabs":
                this.editor.getSession().setUseSoftTabs( newVal );
                break;
            case "tabsize":
                this.editor.getSession().setTabSize( newVal );
                break;
            case "readonly":
                this.editor.setReadOnly( newVal );
                break;
            case "wrapmode":
                this.editor.getSession().setUseWrapMode( newVal !== null );
                break;

        }
    };


    TomalecAceEditorPrototype.onThemeLoaded = function(e){
        var themeId = "#" + e.theme.cssClass;
        this.injectTheme(themeId);
        // Workaround Chrome stable bug, force repaint
        this.container.style.display='none';
        this.container.offsetHeight;
        this.container.style.display='';
    };

    // inject the style tag of a theme to the element
    TomalecAceEditorPrototype.injectTheme = function(themeId){
        var n = document.querySelector(themeId);
        this.shadowRoot.appendChild(cloneStyle(n));
    };

    //helper function to clone a style
    function cloneStyle(style) {
        var s = document.createElement('style');
        s.id = style.id;
        s.textContent = style.textContent;
        return s;
    }



    // CUSTOMIZATION

    TomalecAceEditorPrototype.changeModeForFile = function(filename) {
      var modelist = ace.require("ace/ext/modelist");
      var mode = modelist.getModeForPath(filename).name;
      console.log(filename + " -> " + mode);

      this.changeMode(mode);

    }

    TomalecAceEditorPrototype.changeMode = function(mode) {
      var Mode;
      try {
        Mode = ace.require("ace/mode/" + mode).Mode;
        editor.session.setMode(new Mode());
      } catch (e) {
        // mode is not loaded, so try to load it,
        // there must be a way to make ace do all this stuff as with themes... :(
        var script = document.createElement("Script");
        script.type = "text/javascript";
        script.src = lively4url + "/src/external/ace/modes/mode-" + mode + ".js";
        script.onerror = loadError;
        script.onload = function() {
          Mode = ace.require("ace/mode/" + mode).Mode;
          editor.session.setMode(new Mode());
        }

        document.head.appendChild(script);
      }
    }

    TomalecAceEditorPrototype.changeTheme = function(theme) {
        this.editor.setTheme("ace/theme/" + theme);
    }

    function loadError(err) {
      throw new URIError("Ace config " + err.target.src + " not found. ");
    }

    // var editor = editor = $("lively-editor")[0].shadowRoot.querySelector("#editor").editor;

    TomalecAceEditorPrototype.customizeEditor = function() {
        var editor = this.editor;

        editor.currentSelectionOrLine = function() {
            var sel =  this.getSelectionRange();
            if (sel.start.row == sel.end.row && sel.start.column == sel.end.column) {
                var currline = this.getSelectionRange().start.row;
                text = this.session.getLine(currline);
            } else {
                text = this.getCopyText()
            };
            return text
        }

        editor.commands.addCommand({
            name: "doIt",
            bindKey: {win: "Ctrl-D", mac: "Command-D"},
            exec: (editor) => {
                var text = editor.currentSelectionOrLine()
                var result = this.tryBoundEval(text);
                console.log("" + result)
            }
        })

        editor.commands.addCommand({
            name: "printIt",
            bindKey: {win: "Ctrl-P", mac: "Command-P"},
            exec: (editor) => {
                var text = editor.currentSelectionOrLine()
                var result = this.tryBoundEval(text, true);
            }
        });

        editor.commands.addCommand({
            name: "inspectIt",
            bindKey: {win: "Ctrl-I", mac: "Command-I"},
            exec: (editor) => {
                var text = editor.currentSelectionOrLine()
                var result = this.inspectIt(text, true);
            }
        });

        editor.commands.addCommand({
            name: "doSave",
            bindKey: {win: "Ctrl-S", mac: "Command-S"},
            exec: (editor) => {
                this.doSave(this.editor.getValue());
            }
        });
    };

    TomalecAceEditorPrototype.getDoitContext =  function () {
        return this.doitContext
    }

    TomalecAceEditorPrototype.boundEval =  function (str) {
      // just a hack... to get rid of some async....
      // #TODO make this more general
      // works: await new Promise((r) => r(3))
      // does not work yet: console.log(await new Promise((r) => r(3)))
      if (str.match(/^await /)) {
        str = "(async () => window._ = " + str +")()"
      }

      var ctx = this.getDoitContext() || this,
          interactiveEval = function(text) { return eval(text) };
      // #TODO binding "this" does not work yet, this is needed to build interactive debuggers... and cool workspaces
      var transpiledSource = babel.transform(str, {stage: 0}).code
      // #TODO alt: babel.run
      var result =  interactiveEval.call(ctx, transpiledSource);

      return result
  }

    TomalecAceEditorPrototype.printResult = function (result) {
        var editor = this.editor;
        var text = result
        var fromSel =  editor.getSelectionRange().end;
        editor.selection.selectToPosition(fromSel) // don't replace existing selection
        editor.insert(text)
        var toSel =  editor.getSelectionRange().start;
        editor.selection.moveCursorToPosition(fromSel)
        editor.selection.selectToPosition(toSel)
    }

    TomalecAceEditorPrototype.tryBoundEval = function (str, printResult) {
        var result;
        try { result =  this.boundEval(str) }
        catch(e) {
            document.LastError = e
            console.log("Error: " + e)
            result = e
        }
        if (printResult) {
            if (str.match(/^await/) && result.then) {
              // we will definitly return a promise on which we can wait here
              result.then( result => this.printResult("" +result))
            } else {
              this.printResult(" " +result)
            }
        }
        return result
    }

    TomalecAceEditorPrototype.printObject = function (obj) {
        var result = ""
        Object.keys(obj).forEach((name) => {
            result += "\n   " +name + ": " + obj[name]
        })
        return result
    }

    TomalecAceEditorPrototype.inspectIt = function (str) {
        var result;
        try { result =  this.boundEval(str) }
        catch(e) {
            document.LastError = e
            console.log("Error: " + e)
            result = e
        }
        var result = this.printObject(result)
        this.printResult("" + result)
        return result
    }

    TomalecAceEditorPrototype.doSave = function (text) {
        this.tryBoundEval(text) // just a default implementation...
    }

    TomalecAceEditorPrototype.onResize = function() {
      this.editor.resize();
      console.log("resizing");
    }

    // document.registerElement('juicy-ace-editor', {
    //     prototype: TomalecAceEditorPrototype
    // });


    // Fires when an instance of the element is created
    TomalecAceEditorPrototype.createdCallback = function() {
        console.log("TomalecAceEditorPrototype.createdCallback")
        var value = "";
        Object.defineProperty(this, "value", {
            set: function(val){
                this.editor && this.editor.setValue( val );
                value = val;
            },
            get: function(){
                value = this.editor && this.editor.getValue() || value;
                return value;
            }
        });

        // Creates the shadow root
        // var shadowRoot = this.createShadowRoot();

        // Adds a template clone into shadow root
        // var clone = thatDoc.importNode(template, true);
        this.container = this.shadowRoot.getElementById("juicy-ace-editor-container");
        // shadowRoot.appendChild(clone);

        // this.dispatchEvent(new Event("created")); // already taken care...
    };


   // Refers to the "importer", which is index.html
    var thatDoc = document;

    // Refers to the "importee", which is juicy-ace-editor.html
    var thisDoc = (document._currentScript || document.currentScript).ownerDocument;

    // Gets content from <template>
    // var template = thisDoc.querySelector('#juicy-ace-editor').content;

    var template = document.currentScript.ownerDocument.querySelector('#juicy-ace-editor');
    var clone = document.importNode(template.content, true);

    System.import('../src/client/morphic/component-loader.js').then(loader => {
      loader.register('juicy-ace-editor', clone, TomalecAceEditorPrototype);
    });

}(window, document));
</script>
